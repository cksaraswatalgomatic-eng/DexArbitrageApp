const express = require('express');
const cors = require('cors');
const axios = require('axios');
const cron = require('node-cron');
const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');
const cookieParser = require('cookie-parser');
const { Notifier } = require('./notifier');

let ethPrice = null;
async function getEthPrice() {
  try {
    const response = await axios.get('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT');
    ethPrice = parseFloat(response.data.price);
  } catch (error) {
    console.error('Error fetching ETH price:', error.message);
  }
}

let polPrice = null;
async function getPolPrice() {
  try {
    const response = await axios.get('https://api.binance.com/api/v3/ticker/price?symbol=POLUSDT');
    polPrice = parseFloat(response.data.price);
  } catch (error) {
    console.error('Error fetching POL price:', error.message);
  }
}

let bnbPrice = null;
async function getBnbPrice() {
  try {
    const response = await axios.get('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT');
    bnbPrice = parseFloat(response.data.price);
  } catch (error) {
    console.error('Error fetching BNB price:', error.message);
  }
}

// Fetch the ETH, POL and BNB price once on startup
getEthPrice();
getPolPrice();
getBnbPrice();
// And then every 5 minutes
cron.schedule('*/5 * * * *', getEthPrice);
cron.schedule('*/5 * * * *', getPolPrice);
cron.schedule('*/5 * * * *', getBnbPrice);

// Configuration
const PORT = process.env.PORT || 3000;
const DB_PATH = process.env.DB_PATH || path.join(__dirname, 'data.sqlite');
const BALANCES_URL = process.env.BALANCES_URL || 'http://195.201.178.120:3001/balance';
const TRADES_URL = process.env.TRADES_URL || 'http://195.201.178.120:3001/completed';
const SERVERS_FILE = path.join(__dirname, 'servers.json');

let etherscanBase = process.env.ETHERSCAN_API_URL || 'https://api.etherscan.io/v2';
if (etherscanBase) {
  while (etherscanBase.endsWith('/')) etherscanBase = etherscanBase.slice(0, -1);
}
const ETHERSCAN_API_URL = etherscanBase;
const ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY || '';
const DEFAULT_NOTIFICATION_RULES = {
  profit: { thresholdPercent: 5, cooldownMinutes: 30 },
  lowGas: { threshold: 2, cooldownMinutes: 60 },
  pollFailed: { cooldownMinutes: 30 },
  dailyDigest: { enabled: true, hour: 9, minute: 0, channels: ['email', 'slack'], cooldownMinutes: 1440 },
  hourlyDigest: { enabled: true, minute: 5, channels: ['slack'], cooldownMinutes: 60 },
};

const DEFAULT_SERVER_NOTIFICATION_SETTINGS = {
  telegram: { enabled: false, botToken: '', chatId: '' },
  slack: { enabled: false, webhookUrl: '' },
  email: {
    enabled: false,
    smtpHost: '',
    smtpPort: 587,
    secure: false,
    user: '',
    pass: '',
    from: '',
    to: '',
  },
};

const notifierCache = new Map();
const pollFailureCounts = new Map();

function mergeWithDefaults(source, defaults) {
  if (defaults == null) {
    if (source == null) return source;
    if (Array.isArray(source)) return source.slice();
    if (typeof source === 'object') return { ...source };
    return source;
  }
  if (Array.isArray(defaults)) {
    if (Array.isArray(source)) return source.slice();
    return defaults.slice();
  }
  const result = { ...defaults };
  if (!source || typeof source !== 'object') return result;
  for (const [key, value] of Object.entries(source)) {
    if (value && typeof value === 'object' && !Array.isArray(value) && defaults[key] && typeof defaults[key] === 'object' && !Array.isArray(defaults[key])) {
      result[key] = mergeWithDefaults(value, defaults[key]);
    } else if (Array.isArray(value)) {
      result[key] = value.slice();
    } else if (value !== undefined) {
      result[key] = value;
    }
  }
  return result;
}

function toBoolean(value) {
  if (value === true || value === false) return value;
  if (typeof value === 'number') return value !== 0;
  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') return true;
    if (normalized === 'false' || normalized === '0' || normalized === 'no') return false;
  }
  return Boolean(value);
}

function sanitizeString(value) {
  return value == null ? '' : String(value).trim();
}

function normalizeNotificationSettings(settings) {
  const merged = mergeWithDefaults(settings, DEFAULT_SERVER_NOTIFICATION_SETTINGS);
  const telegram = merged.telegram || {};
  const slack = merged.slack || {};
  const email = merged.email || {};
  const smtpPortNum = Number(email.smtpPort);
  return {
    telegram: {
      enabled: toBoolean(telegram.enabled),
      botToken: sanitizeString(telegram.botToken),
      chatId: sanitizeString(telegram.chatId),
    },
    slack: {
      enabled: toBoolean(slack.enabled),
      webhookUrl: sanitizeString(slack.webhookUrl),
    },
    email: {
      enabled: toBoolean(email.enabled),
      smtpHost: sanitizeString(email.smtpHost),
      smtpPort: Number.isFinite(smtpPortNum) && smtpPortNum > 0 ? smtpPortNum : DEFAULT_SERVER_NOTIFICATION_SETTINGS.email.smtpPort,
      secure: toBoolean(email.secure),
      user: sanitizeString(email.user || email.username),
      pass: sanitizeString(email.pass || email.password),
      from: sanitizeString(email.from),
      to: sanitizeString(email.to || email.recipients),
    },
  };
}
function normalizeServerConfigEntry(entry) {
  const base = entry && typeof entry === 'object' ? { ...entry } : {};
  base.notifications = normalizeNotificationSettings(base.notifications);
  return base;

}
function normalizeServersConfig(input) {
  const cfg = input && typeof input === 'object' ? { ...input } : {};
  cfg.notificationRules = mergeWithDefaults(cfg.notificationRules, DEFAULT_NOTIFICATION_RULES);
  const servers = Array.isArray(cfg.servers) ? cfg.servers : [];
  cfg.servers = servers.map((srv) => normalizeServerConfigEntry(srv));
  if (!cfg.activeId && cfg.servers.length) cfg.activeId = cfg.servers[0].id;
  if (cfg.activeId && !cfg.servers.some((s) => s.id === cfg.activeId)) {
    cfg.activeId = cfg.servers[0]?.id || cfg.activeId;
  }
  return cfg;

}
function getNotifierForServer(serverRef, cfgOverride) {
  if (!serverRef) return null;
  const cfg = cfgOverride || loadServers();
  let server = null;
  let serverId = null;
  if (serverRef && typeof serverRef === 'object' && serverRef.id) {
    serverId = serverRef.id;
    server = cfg.servers.find((s) => s.id === serverId) || serverRef;
  } else {
    serverId = serverRef;
    server = cfg.servers.find((s) => s.id === serverId);
  }
  if (!serverId || !server) return null;
  let signature;
  try {
    signature = JSON.stringify({
      notifications: server.notifications,
      rules: cfg.notificationRules,
    });
  } catch {
    signature = `${Date.now()}-${Math.random()}`;
  }
  const cached = notifierCache.get(serverId);
  if (cached && cached.signature === signature) {
    return cached.instance;
  }
  const notifier = new Notifier({
    serverId,
    serverLabel: server.label || serverId,
    config: server.notifications || {},
    rules: cfg.notificationRules || {},
    db: ensureDb(serverId),
  });
  notifierCache.set(serverId, { signature, instance: notifier });
  return notifier;

function scheduleNotificationTask(fn) {
  setImmediate(() => {
    Promise.resolve().then(fn).catch((err) => {
      console.error('[notify] handler error:', err?.stack || err?.message || err);
    });
  });

function formatNumber(value, digits = 2) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '-';
function formatTimestamp(value) {
  if (!value) return '';
  if (typeof value === 'string') {
    const numeric = Number(value);
    if (Number.isFinite(numeric)) {
      const d = new Date(numeric);
      if (!Number.isNaN(d.getTime())) return d.toISOString();
    }
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) return parsed.toISOString();
    return value;
  }
  const d = new Date(value);
  return Number.isNaN(d.getTime()) ? String(value) : d.toISOString();
}
function formatUsd(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '-';
  return `$${num.toFixed(2)}`;
}
function isWithinMinuteWindow(currentMinute, targetMinute, windowSize = 5) {
  const normalizedTarget = ((Number(targetMinute) % 60) + 60) % 60;
  const diff = (currentMinute - normalizedTarget + 60) % 60;
  return diff >= 0 && diff < windowSize;
}
function computeTradeNetProfit(row, raw) {

  const srcPrice = Number(row?.executedSrcPrice ?? raw?.executedSrcPrice);
  const srcQty = Number(row?.executedQtySrc ?? raw?.executedQtySrc);
  const dstPrice = Number(row?.executedDstPrice ?? raw?.executedDstPrice);
  const dstQty = Number(row?.executedQtyDst ?? raw?.executedQtyDst);
  if (![srcPrice, srcQty, dstPrice, dstQty].every(Number.isFinite)) return null;
  const grossDst = dstQty * dstPrice;
  const grossSrc = srcQty * srcPrice;
  const fee = 0.0002 * grossDst;
  const net = grossDst - grossSrc - fee;
  return Number.isFinite(net) ? net : null;
}

function handleProfitNotifications(server, newTrades) {
  if (!server || !Array.isArray(newTrades) || !newTrades.length) return;
  scheduleNotificationTask(async () => {
    const notifier = getNotifierForServer(server);
    if (!notifier) return;
    const ruleCfg = typeof notifier.getRuleConfig === 'function' ? notifier.getRuleConfig('profit') : (notifier.rules?.profit || {});
    const thresholdRaw = ruleCfg.thresholdPercent ?? ruleCfg.threshold;
    const threshold = Number.isFinite(Number(thresholdRaw)) ? Number(thresholdRaw) : 5;
    for (const entry of newTrades) {
      const row = entry?.row || entry;
      const raw = entry?.raw || {};
      const percent = Number(row?.executedGrossProfit ?? raw?.executedGrossProfit);
      if (!Number.isFinite(percent) || percent < threshold) continue;
      const netProfit = computeTradeNetProfit(row, raw);
      const qty = Number(row?.executedQtySrc ?? raw?.executedQtySrc);
      const lines = [
        `Server: ${server.label}`,
        `Pair: ${row?.pair || raw?.pair || 'unknown'}`,
        `Profit %: ${formatNumber(percent, 2)}`,
      ];
      if (Number.isFinite(netProfit)) lines.push(`Net Profit: ${formatNumber(netProfit, 2)}`);
      if (Number.isFinite(qty)) lines.push(`Src Qty: ${formatNumber(qty, 4)}`);
      const lastUpdate = row?.lastUpdateTime ?? raw?.lastUpdateTime;
      if (lastUpdate) lines.push(`Last Update: ${formatTimestamp(lastUpdate)}`);
      try {
        await notifier.notify('profit', {
          title: `High Profit Trade (${server.label})`,
          message: lines.join('\n'),
          uniqueKey: `trade-${row?.id ?? entry?.id ?? Date.now()}`,
          details: {
            tradeId: row?.id ?? entry?.id ?? null,
            pair: row?.pair || raw?.pair || null,
            profitPercent: percent,
            netProfit,
            serverId: server.id,
          },
        });
      } catch (err) {
        console.error('[notify] profit rule error:', err?.message || err);
      }
    }
  });

  });
}
function handleLowGasNotifications(server, items) {
  if (!server || !Array.isArray(items) || !items.length) return;
  const lowEntries = items.filter((item) => Number(item?.is_low) === 1);
  if (!lowEntries.length) return;
  scheduleNotificationTask(async () => {
    const notifier = getNotifierForServer(server);
    if (!notifier) return;
    const ruleCfg = typeof notifier.getRuleConfig === 'function' ? notifier.getRuleConfig('lowGas') : (notifier.rules?.lowGas || {});
    const configuredThreshold = Number(ruleCfg?.threshold);
    const baseThreshold = Number.isFinite(configuredThreshold) && configuredThreshold > 0 ? configuredThreshold : 2;
    for (const entry of lowEntries) {
      const gas = Number(entry?.gas);
      let threshold = baseThreshold;
      const entryThreshold = Number(entry?.threshold);
      if (Number.isFinite(entryThreshold) && entryThreshold > 0) threshold = entryThreshold;
      if (Number.isFinite(gas) && gas >= threshold) continue;
      const lines = [
        `Server: ${server.label}`,
        `Contract: ${entry?.contract || 'unknown'}`,
        `Gas Remaining: ${formatNumber(gas, 4)}`,
        `Threshold: ${formatNumber(threshold, 4)}`,
      ];
      if (entry?.timestamp) lines.push(`Observed: ${formatTimestamp(entry.timestamp)}`);
      try {
        await notifier.notify('lowGas', {
          title: `Low Gas Alert (${server.label})`,
          message: lines.join('\n'),
          uniqueKey: entry?.contract || undefined,
          details: {
            contract: entry?.contract || null,
            gas,
            threshold,
            serverId: server.id,
          },
        });
      } catch (err) {
        console.error('[notify] low gas rule error:', err?.message || err);
      }
    }
  });



  });
}
function handlePollFailureNotification(server, statusCode, count) {
  if (!server) return;
  scheduleNotificationTask(async () => {
    const notifier = getNotifierForServer(server);
    if (!notifier) return;
    const attempt = Number(count) || 1;
    const message = `Poll Failed (${server.label}): ${statusCode} for /diffdata (attempt ${attempt})`;
    try {
      await notifier.notify('pollFailed', {
        title: `Poll Failed (${server.label})`,
        message,
        uniqueKey: 'diffdata',
        details: {
          statusCode,
          consecutiveFailures: attempt,
          path: '/diffdata',
          serverId: server.id,
        },
      });
    } catch (err) {
      console.error('[notify] poll failed rule error:', err?.message || err);
    }
  });

function buildDailyDigestSummary(server) {
  try {
    const db = ensureDb(server.id);
    const now = Date.now();
    const dayWindow = now - (24 * 60 * 60 * 1000);
    const trades = db.prepare('SELECT pair, status, executedQtyDst, executedDstPrice, executedSrcPrice, executedQtySrc, executedProfit, executedFeeTotal, txFee, lastUpdateTime FROM completed_trades WHERE lastUpdateTime >= ?').all(dayWindow);
    let successCount = 0;
    let failureCount = 0;
    let netProfit = 0;
    let feeSpend = 0;
    const pairStats = new Map();
    for (const row of trades) {
      const profit = computeTradeNetProfit(row, {}) ?? Number(row.executedProfit) ?? 0;
      netProfit += Number.isFinite(profit) ? profit : 0;
      const statusRaw = (row.status || '').toLowerCase();
      const isSuccess = statusRaw.includes('success') || (!statusRaw.includes('fail') && profit > 0);
      if (isSuccess) successCount += 1; else failureCount += 1;
      const pairKey = row.pair || 'n/a';
      const entry = pairStats.get(pairKey) || { count: 0, net: 0 };
      entry.count += 1;
      entry.net += Number.isFinite(profit) ? profit : 0;
      pairStats.set(pairKey, entry);
      const fee = Number(row.executedFeeTotal);
      if (Number.isFinite(fee)) feeSpend += fee;
      const txFee = Number(row.txFee);
      if (Number.isFinite(txFee)) feeSpend += txFee;
    }

    const topPairs = Array.from(pairStats.entries())
      .sort((a, b) => {
        if (b[1].count !== a[1].count) return b[1].count - a[1].count;
        return b[1].net - a[1].net;
      })
      .slice(0, 3)
      .map(([pair, info]) => `${pair} (${info.count}, ${formatNumber(info.net, 2)})`);

    const sinceIso = new Date(dayWindow).toISOString();
    const lowGasRows = db.prepare('SELECT contract, gas FROM gas_balances WHERE is_low = 1 AND timestamp >= ? ORDER BY timestamp DESC').all(sinceIso);
    const lowGasPreview = lowGasRows.slice(0, 5).map((row) => `${row.contract}: ${formatNumber(row.gas, 2)}`);

    const totalTrades = trades.length;
    const successRate = totalTrades ? (successCount / totalTrades) * 100 : 0;

    const lines = [
      `Server: ${server.label}`,
      `Trades (24h): ${totalTrades} | Success: ${successCount} | Fail: ${failureCount} | Success Rate: ${formatNumber(successRate, 1)}%`,
      `Net Profit (24h): ${formatUsd(netProfit)}`,
      `Fee Spend (txFee + executedFeeTotal): ${formatNumber(feeSpend, 2)}`,
      `Low Gas Alerts (24h): ${lowGasRows.length}${lowGasPreview.length ? ' -> ' + lowGasPreview.join(', ') : ''}`,
      `Top Pairs: ${topPairs.length ? topPairs.join(', ') : 'n/a'}`,
    ];

    return {
      message: lines.join('\n'),
      details: {
        trades: totalTrades,
        success: successCount,
        failures: failureCount,
        successRate,
        netProfit,
        feeSpend,
        topPairs,
        lowGasCount: lowGasRows.length,
        lowGasPreview,
      },
    };
  } catch (err) {
    console.error(`[digest:daily:${server.id}] summary error:`, err?.message || err);
    return null;
  }

}
function buildHourlyDigestSummary(server) {
  try {
    const db = ensureDb(server.id);
    const now = Date.now();
    const hourWindow = now - (60 * 60 * 1000);
    const sinceIso = new Date(hourWindow).toISOString();
    const tokenRows = db.prepare('SELECT name, buy, sell, timestamp FROM server_tokens WHERE timestamp >= ? ORDER BY timestamp DESC LIMIT 5').all(sinceIso);
    const tokenCountRow = db.prepare('SELECT COUNT(*) AS count FROM server_tokens WHERE timestamp >= ?').get(sinceIso);
    const tokenCount = tokenCountRow?.count ?? tokenRows.length;
    const tokenSamples = tokenRows.map((row) => `${row.name}: ${formatNumber(row.buy, 3)}/${formatNumber(row.sell, 3)}`);

    const lowGasRows = db.prepare('SELECT contract, gas FROM gas_balances WHERE is_low = 1 AND timestamp >= ? ORDER BY timestamp DESC').all(sinceIso);
    const lowGasCount = lowGasRows.length;
    const lowGasSamples = lowGasRows.slice(0, 5).map((row) => `${row.contract}: ${formatNumber(row.gas, 2)}`);

    const lines = [
      `Server: ${server.label}`,
      `Tokens observed (1h): ${tokenCount}${tokenSamples.length ? ' -> ' + tokenSamples.join(', ') : ''}`,
      `Low gas events (1h): ${lowGasCount}${lowGasSamples.length ? ' -> ' + lowGasSamples.join(', ') : ''}`,
    ];

    return {
      message: lines.join('\n'),
      details: {
        tokenCount,
        tokenSamples,
        lowGasCount,
        lowGasSamples,
      },
    };
  } catch (err) {
    console.error(`[digest:hourly:${server.id}] summary error:`, err?.message || err);
    return null;
  }

async function runDailyDigest() {
  const cfg = loadServers();
  const now = new Date();
  for (const server of cfg.servers) {
    const notifier = getNotifierForServer(server, cfg);
    if (!notifier) continue;
    const ruleCfg = typeof notifier.getRuleConfig === 'function' ? notifier.getRuleConfig('dailyDigest') : (notifier.rules?.dailyDigest || {});
    if (ruleCfg && ruleCfg.enabled === false) continue;
    const targetHour = Number.isFinite(Number(ruleCfg?.hour)) ? Number(ruleCfg.hour) : 9;
    const targetMinute = Number.isFinite(Number(ruleCfg?.minute)) ? Number(ruleCfg.minute) : 0;
    if (now.getHours() !== targetHour) continue;
    if (!isWithinMinuteWindow(now.getMinutes(), targetMinute, 5)) continue;
    const summary = buildDailyDigestSummary(server);
    if (!summary) continue;
    const channels = Array.isArray(ruleCfg?.channels) && ruleCfg.channels.length ? ruleCfg.channels : ['email', 'slack'];
    try {
      await notifier.notify('dailyDigest', {
        title: `Daily Digest (${server.label})`,
        message: summary.message,
        channels,
        uniqueKey: `${server.id}-daily-${now.toISOString().slice(0, 10)}`,
        details: summary.details,
      });
    } catch (err) {
      console.error(`[notify] daily digest error (${server.id}):`, err?.message || err);
    }
  }

}
async function runHourlyDigest() {
  const cfg = loadServers();
  const now = new Date();
  for (const server of cfg.servers) {
    const notifier = getNotifierForServer(server, cfg);
    if (!notifier) continue;
    const ruleCfg = typeof notifier.getRuleConfig === 'function' ? notifier.getRuleConfig('hourlyDigest') : (notifier.rules?.hourlyDigest || {});
    if (ruleCfg && ruleCfg.enabled === false) continue;
    const targetMinute = Number.isFinite(Number(ruleCfg?.minute)) ? Number(ruleCfg.minute) : 5;
    if (!isWithinMinuteWindow(now.getMinutes(), targetMinute, 5)) continue;
    const summary = buildHourlyDigestSummary(server);
    if (!summary) continue;
    const channels = Array.isArray(ruleCfg?.channels) && ruleCfg.channels.length ? ruleCfg.channels : ['slack'];
    try {
      await notifier.notify('hourlyDigest', {
        title: `Hourly Digest (${server.label})`,
        message: summary.message,
        channels,
        uniqueKey: `${server.id}-hourly-${now.toISOString().slice(0, 13)}`,
        details: summary.details,
      });
    } catch (err) {
      console.error(`[notify] hourly digest error (${server.id}):`, err?.message || err);
    }
  }
// App setup
const app = express();
app.use(cors()); // Allow all origins
app.use(express.json({ limit: '2mb' }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

// Multi-server config
function loadServers() {
  if (!fs.existsSync(SERVERS_FILE)) {
    const defaults = normalizeServersConfig({
      activeId: 'bnb',
      servers: [
        { id: 'bnb', label: 'BNB', baseUrl: 'http://195.201.178.120:3001', balancesPath: '/balance', completedPath: '/completed' },
        { id: 'arbitrum', label: 'ARBITRUM', baseUrl: 'http://168.119.69.230:3001', balancesPath: '/balance', completedPath: '/completed' },
        { id: 'base', label: 'BASE', baseUrl: 'http://95.216.27.101:3001', balancesPath: '/balance', completedPath: '/completed' },
      ],
    });
    fs.writeFileSync(SERVERS_FILE, JSON.stringify(defaults, null, 2));
    return defaults;
  }
  try {
    const parsed = JSON.parse(fs.readFileSync(SERVERS_FILE, 'utf8'));
    return normalizeServersConfig(parsed);
  } catch {
    return normalizeServersConfig({
      activeId: 'default',
      servers: [
        { id: 'default', label: 'Default', baseUrl: (BALANCES_URL || '').replace(/\/(balance|balances).*/, ''), balancesPath: '/balance', completedPath: '/completed' },
      ],
    });
  }
function saveServers(cfg) {
  const normalized = normalizeServersConfig(cfg);
  fs.writeFileSync(SERVERS_FILE, JSON.stringify(normalized, null, 2));
  notifierCache.clear();
  return normalized;
function getActiveServer() {
  const cfg = loadServers();
  return cfg.servers.find(s => s.id === cfg.activeId) || cfg.servers[0];

const dbCache = new Map();
const initialTradesSynced = new Set();
function dbPathFor(serverId) {
  if (serverId === 'default' && fs.existsSync(DB_PATH)) return DB_PATH;
  return path.join(__dirname, `data-${serverId}.sqlite`);
function ensureDb(serverId) {
  if (dbCache.has(serverId)) return dbCache.get(serverId);
  const file = dbPathFor(serverId);
  const _db = new Database(file);
  _db.pragma('journal_mode = WAL');
  _db.pragma('synchronous = NORMAL');
  _db.exec(`
    CREATE TABLE IF NOT EXISTS balances_history (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL,
      total_usdt REAL,
      total_coin REAL,
      raw_data TEXT
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS completed_trades (
      id INTEGER PRIMARY KEY,
      fsmType TEXT,
      pair TEXT,
      srcExchange TEXT,
      dstExchange TEXT,
      status TEXT,
      user TEXT,
      estimatedProfitNormalized REAL,
      estimatedProfit REAL,
      estimatedGrossProfit REAL,
      eta TEXT,
      estimatedSrcPrice REAL,
      estimatedDstPrice REAL,
      estimatedQty REAL,
      executedProfitNormalized REAL,
      executedProfit REAL,
      executedGrossProfit REAL,
      executedTime INTEGER,
      executedSrcPrice REAL,
      executedDstPrice REAL,
      executedQtySrc REAL,
      executedQtyDst REAL,
      executedFeeTotal REAL,
      executedFeePercent REAL,
      props TEXT,
      creationTime INTEGER,
      openTime INTEGER,
      lastUpdateTime INTEGER,
      nwId TEXT,
      txFee REAL,
      calculatedVolume REAL,
      conveyedVolume REAL,
      commissionPercent REAL,
      hedge INTEGER,
      raw_data TEXT
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS server_tokens (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL,
      name TEXT NOT NULL,
      buy REAL,
      sell REAL
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS gas_balances (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp TEXT NOT NULL,
      contract TEXT NOT NULL,
      gas REAL,
      is_low INTEGER
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS diff_history (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      curId TEXT NOT NULL,
      ts INTEGER NOT NULL,
      buyDiffBps INTEGER,
      sellDiffBps INTEGER,
      cexVol REAL,
      serverBuy REAL,
      serverSell REAL,
      dexVolume REAL,
      rejectReason TEXT,
      UNIQUE(curId, ts)
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS contract_transactions (
      hash TEXT NOT NULL,
      serverId TEXT NOT NULL,
      timestamp INTEGER NOT NULL,
      isError INTEGER NOT NULL,
      reason TEXT,
      ethPrice REAL,
      polPrice REAL,
      bnbPrice REAL,
      raw_data TEXT,
      PRIMARY KEY (serverId, hash)
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS notifications_log (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      server_id TEXT,
      rule TEXT,
      title TEXT,
      channel TEXT,
      status TEXT,
      message TEXT,
      details TEXT,
      created_at TEXT NOT NULL
    );
  `);
  _db.exec(`
    CREATE TABLE IF NOT EXISTS notification_state (
      key TEXT PRIMARY KEY,
      last_sent INTEGER NOT NULL
    );
  `);
  ensureDiffHistoryColumns(_db);
  dbCache.set(serverId, _db);
  return _db;

function ensureDiffHistoryColumns(db) {
  const columns = new Set(db.prepare('PRAGMA table_info(diff_history)').all().map(col => col.name));
  const migrations = [];
  if (!columns.has('serverBuy')) migrations.push('ALTER TABLE diff_history ADD COLUMN serverBuy REAL');
  if (!columns.has('serverSell')) migrations.push('ALTER TABLE diff_history ADD COLUMN serverSell REAL');
  if (!columns.has('dexVolume')) migrations.push('ALTER TABLE diff_history ADD COLUMN dexVolume REAL');
  if (!columns.has('rejectReason')) migrations.push('ALTER TABLE diff_history ADD COLUMN rejectReason TEXT');
  for (const sql of migrations) {
    try {
      db.exec(sql);
    } catch (err) {
      console.error('[db] diff_history migration failed:', err.message);
    }
  }

async function fetchDiffDataAndStoreFor(server) {
  if (!server) return;
  try {
    const url = server.baseUrl + '/diffdata';
    const resp = await axios.get(url, { timeout: 15000 });
    const data = resp.data;
    pollFailureCounts.set(server.id, 0);
    if (!Array.isArray(data)) return;

    const db = ensureDb(server.id);
    const lookupStmt = db.prepare('SELECT buy, sell FROM server_tokens WHERE name = ? ORDER BY timestamp DESC LIMIT 1');
    const tokenCache = new Map();

    const rows = data.map((raw) => {
      if (!raw || raw.curId == null || raw.ts == null) return null;
      const curId = String(raw.curId);
      const ts = parseInt(raw.ts, 10);
      if (!Number.isFinite(ts)) return null;
      const tokenName = tokenNameFromCurId(curId);

      const cacheKey = tokenName || '';
      let tokenRow = tokenCache.get(cacheKey);
      if (tokenRow === undefined) {
        tokenRow = lookupStmt.get(tokenName);
        if (!tokenRow && tokenName) {
          const upper = tokenName.toUpperCase();
          if (upper !== tokenName) tokenRow = lookupStmt.get(upper);
        }
        if (!tokenRow && tokenName) {
          const lower = tokenName.toLowerCase();
          if (lower !== tokenName) tokenRow = lookupStmt.get(lower);
        }
        tokenCache.set(cacheKey, tokenRow || null);
      }

      return {
        curId,
        ts,
        buyDiffBps: raw.buyDiffBps != null ? parseInt(raw.buyDiffBps, 10) : null,
        sellDiffBps: raw.sellDiffBps != null ? parseInt(raw.sellDiffBps, 10) : null,
        cexVol: safeNumber(raw.cexVol),
        serverBuy: tokenRow ? safeNumber(tokenRow.buy) : null,
        serverSell: tokenRow ? safeNumber(tokenRow.sell) : null,
        dexVolume: safeNumber(raw.dexLiq),
        rejectReason: raw.rr == null ? null : String(raw.rr),
      };
    }).filter(Boolean);

    if (!rows.length) {
      console.log('[diffdata:' + server.label + '] No diff data rows to store.');
      return;
    }

    const stmt = db.prepare('INSERT INTO diff_history (curId, ts, buyDiffBps, sellDiffBps, cexVol, serverBuy, serverSell, dexVolume, rejectReason) ' +
      'VALUES (@curId, @ts, @buyDiffBps, @sellDiffBps, @cexVol, @serverBuy, @serverSell, @dexVolume, @rejectReason) ' +
      'ON CONFLICT(curId, ts) DO UPDATE SET ' +
      'buyDiffBps = COALESCE(excluded.buyDiffBps, diff_history.buyDiffBps), ' +
      'sellDiffBps = COALESCE(excluded.sellDiffBps, diff_history.sellDiffBps), ' +
      'cexVol = COALESCE(excluded.cexVol, diff_history.cexVol), ' +
      'serverBuy = CASE WHEN diff_history.serverBuy IS NULL THEN excluded.serverBuy ELSE diff_history.serverBuy END, ' +
      'serverSell = CASE WHEN diff_history.serverSell IS NULL THEN excluded.serverSell ELSE diff_history.serverSell END, ' +
      'dexVolume = COALESCE(excluded.dexVolume, diff_history.dexVolume), ' +
      'rejectReason = COALESCE(excluded.rejectReason, diff_history.rejectReason)');

    db.transaction((items) => {
      for (const item of items) stmt.run(item);
    })(rows);
    console.log('[diffdata:' + server.label + '] Stored ' + rows.length + ' diff data points.');
  } catch (err) {
    const status = err?.response?.status;
    if (status === 404) {
      const failures = (pollFailureCounts.get(server.id) || 0) + 1;
      pollFailureCounts.set(server.id, failures);
      console.warn(`[diffdata:${server.label}] 404 (not found). Skipping. (attempt ${failures})`);
      handlePollFailureNotification(server, status, failures);
    } else {
      pollFailureCounts.set(server.id, 0);
      console.error(`[diffdata:${server.label}] Fetch/store error:`, err.message);
    }
  }

function propsHasCurId(rawProps, curId) {
  if (!curId) return false;
  try {
    const parsed = typeof rawProps === 'string' ? JSON.parse(rawProps) : rawProps;
    if (!parsed || typeof parsed !== 'object') return false;
    return Object.prototype.hasOwnProperty.call(parsed, curId);
  } catch {
    return false;
  }

function getTradeRawProps(trade) {
  if (!trade) return null;
  const raw = safeJsonParse(trade.raw_data, null);
  if (!raw || raw.props == null) return null;
  return raw.props;

function tradeHasCurId(trade, curId) {
  if (!curId || !trade) return false;
  if (propsHasCurId(trade.props, curId)) return true;
  const rawProps = getTradeRawProps(trade);
  return propsHasCurId(rawProps, curId);

function extractTokensFromPropsSource(source) {
  const obj = safeJsonParse(source, null);
  if (!obj || typeof obj !== 'object') return [];
  const tokens = [];
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      const upper = value.toUpperCase();
      if (upper === 'BUY' || upper === 'SELL') tokens.push(String(key));
    }
  }
  return tokens;

function extractTokensFromTrade(trade) {
  if (!trade) return [];
  const tokens = new Set();
  if (trade.props != null) {
    for (const token of extractTokensFromPropsSource(trade.props)) tokens.add(token);
  }
  const raw = safeJsonParse(trade.raw_data, null);
  if (raw && raw.props != null) {
    for (const token of extractTokensFromPropsSource(raw.props)) tokens.add(token);
  }
  return Array.from(tokens);

function tokenSymbolFromCurId(curId) {
  if (typeof curId !== 'string') return null;
  const parts = curId.split('_').filter(Boolean);
  if (parts.length >= 2) return parts[1];
  return null;

function aggregateTokenMetrics(tradeRows) {
  const metrics = new Map();
  for (const trade of tradeRows) {
    const tokens = extractTokensFromTrade(trade);
    if (!tokens.length) continue;
    const netProfit = (Number(trade.executedQtyDst) * Number(trade.executedDstPrice)) - (Number(trade.executedSrcPrice) * Number(trade.executedQtySrc)) - (0.0002 * Number(trade.executedQtyDst) * Number(trade.executedDstPrice));
    const gp = Number(trade.executedGrossProfit) || 0;
    const props = normalizePropsRaw(trade.props);

    for (const token of tokens) {
      let rec = metrics.get(token);
      if (!rec) {
        rec = {
          token,
          trades: 0,
          wins: 0,
          losses: 0,
          totalGrossProfit: 0,
          totalNetProfit: 0,
          sumCexSlip: 0,
          countCexSlip: 0,
          sumDexSlip: 0,
          countDexSlip: 0,
          sumDiff: 0,
          countDiff: 0,
        };
        metrics.set(token, rec);
      }

      rec.trades += 1;
      rec.totalGrossProfit += gp;
      if (Number.isFinite(netProfit)) rec.totalNetProfit += netProfit;
      if (gp > 0) rec.wins += 1;
      else if (gp < 0) rec.losses += 1;

      if (Number.isFinite(props.CexSlip)) { rec.sumCexSlip += props.CexSlip; rec.countCexSlip++; }
      if (Number.isFinite(props.DexSlip)) { rec.sumDexSlip += props.DexSlip; rec.countDexSlip++; }
      if (Number.isFinite(props.Diff)) { rec.sumDiff += props.Diff; rec.countDiff++; }
    }
  }
  return metrics;

function tokenNameFromCurId(curId) {
  if (typeof curId !== 'string') return null;
  const parts = curId.split('_').filter(Boolean);
  if (parts.length >= 2) return parts[1];
  return parts[0] || curId || null;

function calculateTotals(snapshot) {
  let totalUsdt = 0;

  if (!snapshot || typeof snapshot !== 'object') {
    return { totalUsdt: null, totalCoin: null };
  }

  for (const [name, ex] of Object.entries(snapshot)) {
    if (!ex || typeof ex !== 'object') continue;

    if (name === 'BinanceF') {
      totalUsdt += Number(ex.usdtVal) || 0;
    } else {
      totalUsdt += Number(ex.coinVal) || 0;
    }
  }
  // The meaning of totalCoin is now ambiguous, so we nullify it.
  return {
    totalUsdt: Number.isFinite(totalUsdt) ? totalUsdt : null,
    totalCoin: null,
  };


// Helper to compute per-snapshot DEX and CEX totals
function computeDexCex(snapshot) {
  let dexTotal = 0;
  let cexTotal = 0;

  if (!snapshot || typeof snapshot !== 'object') {
    return { dexTotal: 0, cexTotal: 0, combined: 0 };
  }

  for (const [name, ex] of Object.entries(snapshot)) {
    if (!ex || typeof ex !== 'object') continue;

    if (name === 'BinanceF') {
      cexTotal += Number(ex.usdtVal) || 0;
    } else {
      dexTotal += Number(ex.coinVal) || 0;
    }
  }

  return { dexTotal, cexTotal, combined: dexTotal + cexTotal };

// Normalize various props encodings into a canonical shape
function normalizePropsRaw(input) {
  try {
    const p = typeof input === 'string' ? JSON.parse(input) : (input || {});
    const out = {};

    // Direct keys
    if (p && (p.Diff != null || p.DexSlip != null || p.CexSlip != null || p.Dex != null || p.Exec != null)) {
      if (p.Diff != null) out.Diff = Number(p.Diff);
      if (p.DexSlip != null) out.DexSlip = Number(p.DexSlip);
      if (p.CexSlip != null) out.CexSlip = Number(p.CexSlip);
      if (p.Dex != null) out.Dex = String(p.Dex);
      if (p.Exec != null) out.Exec = String(p.Exec);
    } else {
      // Heuristic format: { 'SOME_link_xxxx': 'SELL', '0.14': '0.06', 'Market': '0.27' }
      // Exec key is one of these, value is CexSlip
      const execKey = ['Market','Limit','PostOnly','IOC','FOK'].find(k => Object.prototype.hasOwnProperty.call(p, k));
      if (execKey) { out.Exec = execKey; const v = Number(p[execKey]); if (Number.isFinite(v)) out.CexSlip = v; }
      // Find Dex as value of any key whose value is 'BUY' or 'SELL'
      for (const [k, v] of Object.entries(p)) {
        if (v === 'BUY' || v === 'SELL') {
          out.Dex = String(v);
          break;
        }
      }
      // Find numeric key/value pair -> key = Diff, value = DexSlip
      for (const [k, v] of Object.entries(p)) {
        const nk = Number(k); const nv = Number(v);
        if (Number.isFinite(nk) && Number.isFinite(nv)) { out.Diff = nk; out.DexSlip = nv; break; }
      }
    }
    return out;
  } catch (e) {
    console.error('normalizePropsRaw - error:', e);
    return {};
  }

async function fetchBalancesAndStoreFor(server) {
  if (!server) return;
  try {
    const url = server.baseUrl + (server.balancesPath || '/balance');
    const resp = await axios.get(url, { timeout: 15000 });
    const data = resp.data;
    const { totalUsdt, totalCoin } = calculateTotals(data);
    const row = { timestamp: new Date().toISOString(), total_usdt: totalUsdt, total_coin: totalCoin, raw_data: JSON.stringify(data) };
    const db = ensureDb(server.id);
    db.prepare(`INSERT INTO balances_history (timestamp, total_usdt, total_coin, raw_data) VALUES (@timestamp,@total_usdt,@total_coin,@raw_data)`).run(row);
    console.log(`[balances:${server.label}] Stored @ ${row.timestamp} | total_usdt=${totalUsdt}${totalCoin != null ? ` total_coin=${totalCoin}` : ''}`);
  } catch (err) {
    const status = err?.response?.status;
    if (status === 404) console.log(`[balances:${server.label}] 404 (not found). Skipping.`);
    else console.error(`[balances:${server.label}] Fetch/store error:`, err.message);
  }

function storeCompletedTrades(server, trades, sourceLabel = 'recent') {
  if (!server) return 0;
  const arr = Array.isArray(trades) ? trades : [];
  if (!arr.length) {
    if (sourceLabel) console.log(`[trades:${server.label}] No trades from ${sourceLabel}.`);
    return 0;
  }

  const db = ensureDb(server.id);
  let inserted = 0;
  const newTrades = [];

  const insertTradeStmt = db.prepare(`INSERT OR IGNORE INTO completed_trades (
      id, fsmType, pair, srcExchange, dstExchange, status, user,
      estimatedProfitNormalized, estimatedProfit, estimatedGrossProfit, eta,
      estimatedSrcPrice, estimatedDstPrice, estimatedQty,
      executedProfitNormalized, executedProfit, executedGrossProfit, executedTime,
      executedSrcPrice, executedDstPrice, executedQtySrc, executedQtyDst,
      executedFeeTotal, executedFeePercent, props, creationTime, openTime, lastUpdateTime,
      nwId, txFee, calculatedVolume, conveyedVolume, commissionPercent, hedge, raw_data
    ) VALUES (
      @id, @fsmType, @pair, @srcExchange, @dstExchange, @status, @user,
      @estimatedProfitNormalized, @estimatedProfit, @estimatedGrossProfit, @eta,
      @estimatedSrcPrice, @estimatedDstPrice, @estimatedQty,
      @executedProfitNormalized, @executedProfit, @executedGrossProfit, @executedTime,
      @executedSrcPrice, @executedDstPrice, @executedQtySrc, @executedQtyDst,
      @executedFeeTotal, @executedFeePercent, @props, @creationTime, @openTime, @lastUpdateTime,
      @nwId, @txFee, @calculatedVolume, @conveyedVolume, @commissionPercent, @hedge, @raw_data
    )`);

  const insert = db.transaction((items) => {
    for (const t of items) {
      const normProps = normalizePropsRaw(t.props);
      const row = {
        id: t.id,
        fsmType: t.fsmType ?? null,
        pair: t.pair ?? null,
        srcExchange: t.srcExchange ?? null,
        dstExchange: t.dstExchange ?? null,
        status: t.status ?? null,
        user: t.user ?? null,
        estimatedProfitNormalized: safeNumber(t.estimatedProfitNormalized),
        estimatedProfit: safeNumber(t.estimatedProfit),
        estimatedGrossProfit: safeNumber(t.estimatedGrossProfit),
        eta: t.eta == null ? null : String(t.eta),
        estimatedSrcPrice: safeNumber(t.estimatedSrcPrice),
        estimatedDstPrice: safeNumber(t.estimatedDstPrice),
        estimatedQty: safeNumber(t.estimatedQty),
        executedProfitNormalized: safeNumber(t.executedProfitNormalized),
        executedProfit: safeNumber(t.executedProfit),
        executedGrossProfit: safeNumber(t.executedGrossProfit),
        executedTime: t.executedTime != null ? parseInt(t.executedTime) : null,
        executedSrcPrice: safeNumber(t.executedSrcPrice),
        executedDstPrice: safeNumber(t.executedDstPrice),
        executedQtySrc: safeNumber(t.executedQtySrc),
        executedQtyDst: safeNumber(t.executedQtyDst),
        executedFeeTotal: safeNumber(t.executedFeeTotal),
        executedFeePercent: safeNumber(t.executedFeePercent),
        props: Object.keys(normProps).length ? JSON.stringify(normProps) : (t.props == null ? null : String(t.props)),
        creationTime: t.creationTime != null ? parseInt(t.creationTime) : null,
        openTime: t.openTime != null ? parseInt(t.openTime) : null,
        lastUpdateTime: t.lastUpdateTime != null ? parseInt(t.lastUpdateTime) : null,
        nwId: t.nwId == null ? null : String(t.nwId),
        txFee: safeNumber(t.txFee),
        calculatedVolume: safeNumber(t.calculatedVolume),
        conveyedVolume: safeNumber(t.conveyedVolume),
        commissionPercent: safeNumber(t.commissionPercent),
        hedge: t.hedge === true ? 1 : t.hedge === false ? 0 : null,
        raw_data: JSON.stringify(t)
      };
      const info = insertTradeStmt.run(row);
      if (info.changes > 0) {
        inserted += 1;
        newTrades.push({ row, raw: t });
      }
    }
  });

  insert(arr);
  if (newTrades.length) handleProfitNotifications(server, newTrades);
  console.log(`[trades:${server.label}] Inserted new trades${sourceLabel ? ` (${sourceLabel})` : ''}: ${inserted}/${arr.length}`);
  return inserted;

async function fetchTradesAndStoreFor(server) {
  if (!server) return;
  try {
    const url = server.baseUrl + (server.completedPath || '/completed');
    const resp = await axios.get(url, { timeout: 20000 });
    const arr = Array.isArray(resp.data) ? resp.data : [];
    storeCompletedTrades(server, arr, 'delta');
  } catch (err) {
    console.error(`[trades:${server?.label}] Fetch/store error:`, err.message);
  }

async function fetchAllTradesAndStoreFor(server) {
  if (!server) return false;
  try {
    const url = server.baseUrl + (server.completedAllPath || '/completedall');
    const resp = await axios.get(url, { timeout: 60000 });
    const arr = Array.isArray(resp.data) ? resp.data : [];
    storeCompletedTrades(server, arr, 'bootstrap');
    return true;
  } catch (err) {
    console.error(`[trades:${server?.label}] Fetch/store (completedall) error:`, err.message);
    return false;
  }

async function fetchStatusAndStoreFor(server) {
  if (!server) return;
  try {
    const serverIp = server.baseUrl.split(':')[1].substring(2);
    const resp = await axios.get(`http://${serverIp}:3001/`, { timeout: 10000 });
    const text = resp.data;
    if (typeof text !== 'string') return;

    const timestamp = new Date().toISOString();
    const db = ensureDb(server.id);

    // Parse and store tokens
    const sdiffLine = text.split(/\r?\n/).find(l => l.startsWith('SDIFF_Uniswap_ckhvar2'));
    if (sdiffLine) {
      const propsIndex = sdiffLine.indexOf('Mindiff:');
      const propsStr = propsIndex > -1 ? sdiffLine.substring(propsIndex) : '';
      const tokens = propsStr.match(/\w+\([\d.]+,[\d.]+\)/g)?.map(t => {
        const [name, values] = t.split('(');
        const [buy, sell] = values.slice(0, -1).split(',');
        return { name, buy: safeNumber(buy), sell: safeNumber(sell) };
      });

      if (tokens && tokens.length) {
        const stmt = db.prepare('INSERT INTO server_tokens (timestamp, name, buy, sell) VALUES (@timestamp, @name, @buy, @sell)');
        db.transaction((items) => {
          for (const item of items) stmt.run({ timestamp, ...item });
        })(tokens);
        console.log(`[status:${server.label}] Stored ${tokens.length} tokens.`);
      }
    }

    // Parse and store gas balances
    const blacklistLine = text.split(/\r?\n/).find(l => l.startsWith('SDIFF Uniswap BlackList:'));
    if (blacklistLine) {
      const str = blacklistLine.replace('SDIFF Uniswap BlackList:', '').trim();
      let gasThreshold = 2;
      try {
        const notifier = getNotifierForServer(server);
        if (notifier) {
          const ruleCfg = typeof notifier.getRuleConfig === 'function' ? notifier.getRuleConfig('lowGas') : (notifier.rules?.lowGas || {});
          const configured = Number(ruleCfg?.threshold);
          if (Number.isFinite(configured) && configured > 0) gasThreshold = configured;
        }
      } catch (notifyErr) {
        if (process.env.DEBUG_NOTIFIER) console.warn(`[notify] low gas threshold lookup failed for ${server.id}:`, notifyErr?.message || notifyErr);
      }
      const gasBalances = str.split(',').map(item => item.trim()).filter(Boolean).map(item => {
        const [key, value] = item.split(':');
        if (key && value !== undefined) {
          const valNum = parseFloat(value);
          return { contract: key, gas: valNum, is_low: valNum < gasThreshold ? 1 : 0, threshold: gasThreshold, timestamp };
        }
        return null;
      }).filter(Boolean);

      if (gasBalances && gasBalances.length) {
        const stmt = db.prepare('INSERT INTO gas_balances (timestamp, contract, gas, is_low) VALUES (@timestamp, @contract, @gas, @is_low)');
        db.transaction((items) => {
          for (const item of items) stmt.run({ timestamp, ...item });
        })(gasBalances);
        console.log(`[status:${server.label}] Stored ${gasBalances.length} gas balances.`);
        handleLowGasNotifications(server, gasBalances);
      }
    }
  } catch (err) {
    console.error(`[status:${server?.label}] Fetch/store error:`, err.message);
  }

async function fetchContractTxsAndStoreFor(server) {
  if (!server || !server.contractAddress) return;

  const { id: serverId, contractAddress, chainId, explorerApiKey, explorerApiBase } = server;
  const db = ensureDb(serverId);

  try {
    const apiKey = (explorerApiKey || ETHERSCAN_API_KEY || '').trim();
    const useUnifiedApi = Number.isFinite(chainId) && chainId > 0 && apiKey;

    const extractTxs = (payload) => {
      if (!payload) return [];
      if (Array.isArray(payload.result)) return payload.result;
      if (Array.isArray(payload.data)) return payload.data;
      if (payload.result && Array.isArray(payload.result.transactions)) return payload.result.transactions;
      return [];
    };

    const fetchLegacy = async () => {
      if (!explorerApiBase) return [];
      const legacyApi = explorerApiBase.replace(/\/?$/, '');
      const legacyUrl = `${legacyApi}/api?module=account&action=txlist&address=${encodeURIComponent(contractAddress)}&sort=desc&page=1&offset=1000${explorerApiKey ? `&apikey=${encodeURIComponent(explorerApiKey)}` : ''}`;
      const data = await fetchThrottledEtherscan(legacyUrl);
      if (typeof (data && data.result) === 'string' && data.result.toLowerCase().includes('max rate limit')) {
        throw new Error(data.result);
      }
      return extractTxs(data);
    };

    let txs = [];
    if (useUnifiedApi) {
      const params = new URLSearchParams({
        chainid: String(chainId),
        module: 'account',
        action: 'txlist',
        address: contractAddress,
        sort: 'desc',
        page: '1',
        offset: '1000'
      });
      if (apiKey) params.append('apikey', apiKey);
      const unifiedUrl = `${ETHERSCAN_API_URL}/api?${params.toString()}`;
      const data = await fetchThrottledEtherscan(unifiedUrl);
      if (typeof (data && data.result) === 'string' && data.result.toLowerCase().includes('max rate limit')) {
        throw new Error(data.result);
      }
      txs = extractTxs(data);
      if ((!txs || txs.length === 0) && explorerApiBase && data && ((data.status === '0' && data.result) || data.message === 'NOTOK')) {
        txs = await fetchLegacy();
      }
    } else {
      txs = await fetchLegacy();
    }

    if (txs.length > 0) {
      const stmt = db.prepare(`
        INSERT OR IGNORE INTO contract_transactions (hash, serverId, timestamp, isError, reason, ethPrice, polPrice, bnbPrice, raw_data)
        VALUES (@hash, @serverId, @timestamp, @isError, @reason, @ethPrice, @polPrice, @bnbPrice, @raw_data)
      `);

      db.transaction((items) => {
        for (const t of items) {
          const isError = String(t.isError || t.errorCode || '0').trim() !== '0';
          const reason = t.txreceipt_status === '0' ? 'Reverted' : (t.errDescription || t.revertReason || 'Unknown');
          let price = { ethPrice: null, polPrice: null, bnbPrice: null };
          if (server.explorerSite === 'https://polygonscan.com') {
            price.polPrice = polPrice;
          } else if (server.explorerSite === 'https://bscscan.com') {
            price.bnbPrice = bnbPrice;
          } else {
            price.ethPrice = ethPrice;
          }

          stmt.run({
            hash: t.hash,
            serverId: serverId,
            timestamp: Number(t.timeStamp) * 1000,
            isError: isError ? 1 : 0,
            reason: isError ? reason : null,
            ...price,
            raw_data: JSON.stringify(t)
          });
        }
      })(txs);
      console.log(`[contracts:${serverId}] Stored ${txs.length} transactions.`);
    }

  } catch (err) {
    console.error(`[contracts:${serverId}] Fetch/store error:`, err.message);
  }

}
async function ensureInitialTradesSync(server) {
  if (!server) return;
  if (initialTradesSynced.has(server.id)) return;
  const ok = await fetchAllTradesAndStoreFor(server);
  if (ok) initialTradesSynced.add(server.id);

async function fetchAllAndStore() {
  const cfg = loadServers();
  for (const s of cfg.servers) {
    await ensureInitialTradesSync(s);
    // Fetch status first to ensure it's processed before other data
    await fetchStatusAndStoreFor(s);
    // Then fetch balances and trades in parallel
    await Promise.allSettled([fetchBalancesAndStoreFor(s), fetchTradesAndStoreFor(s), fetchDiffDataAndStoreFor(s), fetchContractTxsAndStoreFor(s)]);
  }

// Schedule: every 2 minutes
cron.schedule('*/2 * * * *', () => {
  console.log('[cron] Running scheduled fetch...');
  fetchAllAndStore();
});
cron.schedule('*/5 * * * *', () => {
  runHourlyDigest().catch((err) => console.error('[cron] hourly digest error:', err?.message || err));
  runDailyDigest().catch((err) => console.error('[cron] daily digest error:', err?.message || err));
});

// Kick off initial fetch on startup (non-blocking)
fetchAllAndStore();

app.get('/trades/history', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const token = req.query.token;
    const curId = req.query.curId;
    let startTime = req.query.startTime != null && req.query.startTime !== '' ? Number(req.query.startTime) : null;
    let endTime = req.query.endTime != null && req.query.endTime !== '' ? Number(req.query.endTime) : null;
    let minNetProfit = req.query.minNetProfit != null && req.query.minNetProfit !== '' ? Number(req.query.minNetProfit) : null;
    let maxNetProfit = req.query.maxNetProfit != null && req.query.maxNetProfit !== '' ? Number(req.query.maxNetProfit) : null;

    if (!Number.isFinite(startTime)) startTime = null;
    if (!Number.isFinite(endTime)) endTime = null;
    if (!Number.isFinite(minNetProfit)) minNetProfit = null;
    if (!Number.isFinite(maxNetProfit)) maxNetProfit = null;

    if (!token && !curId) {
      return res.status(400).json({ error: 'token or curId parameter is required' });
    }

    let query = 'SELECT id, lastUpdateTime, executedQtyDst, executedDstPrice, executedSrcPrice, executedQtySrc, props, raw_data FROM completed_trades';
    const clauses = [];
    const params = [];

    if (token) {
      clauses.push('pair LIKE ?');
      params.push(`%${token}%`);
    }

    if (startTime != null && endTime != null) {
      clauses.push('lastUpdateTime BETWEEN ? AND ?');
      params.push(startTime, endTime);
    }

    if (clauses.length) {
      query += ' WHERE ' + clauses.join(' AND ');
    }

    const trades = db.prepare(query).all(params);
    console.log(`[api:/trades/history] params token=${token || 'none'} curId=${curId || 'none'} start=${startTime ?? 'none'} end=${endTime ?? 'none'} fetched=${trades.length}`);

    let filteredTrades = trades;
    if (curId) {
      const matching = [];
      const nonMatchingSamples = [];
      for (const trade of trades) {
        if (tradeHasCurId(trade, curId)) {
          matching.push(trade);
        } else if (nonMatchingSamples.length < 5) {
          const parsedProps = safeJsonParse(trade.props, {});
          const rawProps = getTradeRawProps(trade);
          nonMatchingSamples.push({
            id: trade.id,
            lastUpdateTime: trade.lastUpdateTime,
            propsKeys: parsedProps && typeof parsedProps === 'object' ? Object.keys(parsedProps) : [],
            rawPropsKeys: rawProps && typeof rawProps === 'object' ? Object.keys(rawProps) : []
          });
        }
      }
      console.log(`[api:/trades/history] curId=${curId} matches=${matching.length}`);
      if (!matching.length && nonMatchingSamples.length) {
        console.log('[api:/trades/history] sample non-matching trades:', nonMatchingSamples);
      }
      filteredTrades = matching;
    } else {
      console.log(`[api:/trades/history] no curId filter applied; using ${filteredTrades.length} trades`);
    }

    const tradesWithNetProfit = filteredTrades.map(t => {
      const netProfit = (t.executedQtyDst * t.executedDstPrice) - (t.executedSrcPrice * t.executedQtySrc) - (0.0002 * t.executedQtyDst * t.executedDstPrice);
      const rawProps = getTradeRawProps(t);
      const rawPropsStr = rawProps == null ? null : (typeof rawProps === 'string' ? rawProps : JSON.stringify(rawProps));
      return {
        lastUpdateTime: t.lastUpdateTime,
        netProfit: netProfit,
        props: t.props,
        rawProps: rawPropsStr
      };
    });

    const tradesFilteredByProfit = tradesWithNetProfit.filter(t => {
      if (minNetProfit !== null && t.netProfit < minNetProfit) {
        return false;
      }
      if (maxNetProfit !== null && t.netProfit > maxNetProfit) {
        return false;
      }
      return true;
    });

    console.log(`[api:/trades/history] returning ${tradesFilteredByProfit.length} trades after profit filter`);
    res.json(tradesFilteredByProfit);
  } catch (err) {
    console.error('[api:/trades/history] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/diffdata/tokens', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const rows = db.prepare('SELECT DISTINCT curId FROM diff_history ORDER BY curId').all();
    res.json(rows.map(r => r.curId));
  } catch (err) {
    console.error('[api:/diffdata/tokens] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/diffdata/history', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const curId = req.query.curId;
    const limit = Math.max(1, Math.min(parseInt(req.query.limit) || 5000, 5000));
    const offset = Math.max(0, parseInt(req.query.offset) || 0);
    const minBuyDiffBps = req.query.minBuyDiffBps ? parseFloat(req.query.minBuyDiffBps) : null;
    const maxBuyDiffBps = req.query.maxBuyDiffBps ? parseFloat(req.query.maxBuyDiffBps) : null;
    const minSellDiffBps = req.query.minSellDiffBps ? parseFloat(req.query.minSellDiffBps) : null;
    const maxSellDiffBps = req.query.maxSellDiffBps ? parseFloat(req.query.maxSellDiffBps) : null;

    if (!curId) {
      return res.status(400).json({ error: 'curId parameter is required' });
    }

    let query = 'SELECT curId, ts, buyDiffBps, sellDiffBps, cexVol, serverBuy, serverSell, dexVolume, rejectReason FROM diff_history WHERE curId = ?';
    const params = [curId];

    if (minBuyDiffBps !== null) {
      query += ' AND buyDiffBps >= ?';
      params.push(minBuyDiffBps);
    }
    if (maxBuyDiffBps !== null) {
      query += ' AND buyDiffBps <= ?';
      params.push(maxBuyDiffBps);
    }
    if (minSellDiffBps !== null) {
      query += ' AND sellDiffBps >= ?';
      params.push(minSellDiffBps);
    }
    if (maxSellDiffBps !== null) {
      query += ' AND sellDiffBps <= ?';
      params.push(maxSellDiffBps);
    }

    query += ' ORDER BY ts DESC LIMIT ? OFFSET ?';
    params.push(limit, offset);

    const diffRows = db.prepare(query).all(params);

    const tokenName = tokenNameFromCurId(curId);
    const serverTokenStmt = db.prepare('SELECT buy, sell FROM server_tokens WHERE name = ? ORDER BY timestamp DESC LIMIT 1');
    let serverToken = tokenName ? serverTokenStmt.get(tokenName) : null;
    if (!serverToken && tokenName) {
      const upper = tokenName.toUpperCase();
      if (upper !== tokenName) serverToken = serverTokenStmt.get(upper);
    }
    if (!serverToken && tokenName) {
      const lower = tokenName.toLowerCase();
      if (lower !== tokenName) serverToken = serverTokenStmt.get(lower);
    }

    const normalizedRows = diffRows.reverse().map((row) => {
      const ts = Number(row.ts);
      const buy = row.serverBuy != null ? safeNumber(row.serverBuy) : null;
      const sell = row.serverSell != null ? safeNumber(row.serverSell) : null;
      const dexVolume = row.dexVolume != null ? safeNumber(row.dexVolume) : null;
      const cexVol = safeNumber(row.cexVol);
      const normalized = {
        curId: row.curId,
        ts: Number.isFinite(ts) ? ts : null,
        buyDiffBps: safeNumber(row.buyDiffBps),
        sellDiffBps: safeNumber(row.sellDiffBps),
        cexVol,
        serverBuy: buy,
        serverSell: sell,
        dexVolume,
        rejectReason: row.rejectReason == null ? null : String(row.rejectReason),
      };
      if (normalized.serverBuy == null && serverToken?.buy != null) {
        normalized.serverBuy = safeNumber(serverToken.buy);
      }
      if (normalized.serverSell == null && serverToken?.sell != null) {
        normalized.serverSell = safeNumber(serverToken.sell);
      }
      return normalized;
    });

    const normalizedServerToken = serverToken ? {
      buy: safeNumber(serverToken.buy),
      sell: safeNumber(serverToken.sell),
    } : null;

    res.json({
      diffData: normalizedRows,
      serverToken: normalizedServerToken
    });
  } catch (err) {
    console.error('[api:/diffdata/history] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API Endpoints
function getDbFromReq(req) {
  const serverId = req.query.serverId || loadServers().activeId;
  return ensureDb(serverId);

app.get('/balances', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const row = db.prepare(
      'SELECT timestamp, total_usdt, total_coin FROM balances_history ORDER BY id DESC LIMIT 1'
    ).get();
    if (!row) return res.status(404).json({ error: 'No balance data yet' });
    res.json(row);
  } catch (err) {
    console.error('[api:/balances] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/balances/history', (req, res) => {
  try {
    const limit = Math.max(1, Math.min(parseInt(req.query.limit) || 500, 5000));
    const beforeTimestamp = req.query.before_timestamp; // New parameter
    const db = getDbFromReq(req);

    let query = 'SELECT timestamp, total_usdt, total_coin, raw_data FROM balances_history';
    const params = [];

    if (beforeTimestamp) {
      query += ' WHERE timestamp < ?';
      params.push(beforeTimestamp);
    }

    query += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(limit);

    const rows = db.prepare(query).all(params);

    // Reverse the order to send oldest first, as expected by Chart.js
    const sortedRows = rows.reverse();

    const enriched = sortedRows.map(r => {
      let snapshot;
      try { snapshot = JSON.parse(r.raw_data); } catch { snapshot = null; }
      const parts = computeDexCex(snapshot);
      // Keep legacy total_usdt if combined is not computable
      const combined = Number.isFinite(parts.combined) && parts.combined !== 0 ? parts.combined : r.total_usdt;
      return {
        timestamp: r.timestamp,
        total_usdt: combined,
        total_dex_usdt: parts.dexTotal,
        total_cex_usdt: parts.cexTotal
      };
    });
    res.json(enriched);
  } catch (err) {
    console.error('[api:/balances/history] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});


app.get('/notifications/recent', (req, res) => {
  try {
    const serverId = req.query.serverId || loadServers().activeId;
    if (!serverId) return res.status(400).json({ error: 'serverId required' });
    const limitParam = parseInt(req.query.limit, 10);
    const limit = Number.isFinite(limitParam) ? Math.max(1, Math.min(limitParam, 200)) : 50;
    const db = ensureDb(serverId);
    const rows = db.prepare('SELECT id, server_id, rule, title, channel, status, message, details, created_at ' +
      'FROM notifications_log WHERE server_id = ? ORDER BY datetime(created_at) DESC, id DESC LIMIT ?').all(serverId, limit);
    const items = rows.map((row) => ({
      id: row.id,
      serverId: row.server_id,
      rule: row.rule,
      title: row.title,
      channel: row.channel,
      status: row.status,
      message: row.message,
      details: safeJsonParse(row.details, row.details),
      createdAt: row.created_at,
    }));
    res.json({ items, limit, serverId });
  } catch (err) {
    console.error('[api:/notifications/recent] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Detailed per-exchange balances derived from the latest stored snapshot
app.get('/balances/exchanges', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const row = db.prepare(
      'SELECT timestamp, raw_data FROM balances_history ORDER BY id DESC LIMIT 1'
    ).get();
    if (!row) return res.status(404).json({ error: 'No balance data yet' });

    let snapshot;
    try {
      snapshot = JSON.parse(row.raw_data);
    } catch (_) {
      return res.status(500).json({ error: 'Corrupt balance snapshot' });
    }

    const result = { timestamp: row.timestamp, dex: [], cex: null };

    // DEX example: Uniswap_BEP20
    for (const [exName, ex] of Object.entries(snapshot || {})) {
      if (!ex || typeof ex !== 'object') continue;
      if (exName === 'BinanceF') continue; // handled in CEX section

      // Only include if it looks like a DEX style with balanceMap
      if (ex.balanceMap && (ex.usdtVal != null || ex.coinVal != null)) {
        const tokens = [];
        for (const b of Object.values(ex.balanceMap)) {
          if (!b || typeof b !== 'object') continue;
          const total = Number(b.total) || 0;
          const totalUsdt = Number(b.totalUsdt) || 0;
          if (totalUsdt > 0.1) {
            tokens.push({ currency: String(b.currency || ''), total, totalUsdt });
          }
        }
        // Sort desc by USDT value
        tokens.sort((a, b) => b.totalUsdt - a.totalUsdt);
        const totalUSDT = Number(ex.coinVal) || 0;
        result.dex.push({ exchange: exName, totalUSDT, tokens });
      }
    }

    // CEX: BinanceF calculation
    const binanceF = snapshot?.BinanceF;
    if (binanceF && binanceF.balanceMap) {
      const tokens = [];
      let usdtTotal = 0;
      let unrealizedSum = 0;
      for (const b of Object.values(binanceF.balanceMap)) {
        if (!b || typeof b !== 'object') continue;
        const currency = String(b.currency || '');
        const total = Number(b.total) || 0;
        const lev = Number(b.leverage) || 1;
        const entry = Number(b.entryPrice) || 0;
        const uPnL = Number(b.unrealizedProfit) || 0;
        let usdtValue;
        let totalUsdt;
        if (currency.toLowerCase() === 'usdt') {
          usdtValue = total;
          usdtTotal += total;
          totalUsdt = total;
        } else {
          usdtValue = (entry * total) / (lev || 1) + uPnL;
          unrealizedSum += uPnL;
          totalUsdt = b.total * b.entryPrice;
        }
        const available = Number(b.available) || 0;
        if (Math.abs(usdtValue) > 0.1) {
          tokens.push({ currency, total, available, usdtValue, totalUsdt, leverage: lev, entryPrice: entry, unrealizedProfit: uPnL });
        }
      }
      tokens.sort((a, b) => (b.usdtValue || 0) - (a.usdtValue || 0));
      const totalUSDT = Number(binanceF.usdtVal) || 0;
      result.cex = { exchange: 'BinanceF', totalUSDT, tokens, unrealizedSum, usdtTotal };
    }

    // DEX vs CEX Comparison
    const comparison = [];
    if (result.dex.length && result.cex) {
      const cexTokens = new Map(result.cex.tokens.map(t => [t.currency.split('/')[0], t]));
      for (const dex of result.dex) {
        for (const token of dex.tokens) {
          const dexTokenName = token.currency.split('_')[1];
          if (cexTokens.has(dexTokenName)) {
            const cexToken = cexTokens.get(dexTokenName);
            const difference = token.totalUsdt - cexToken.totalUsdt;
            comparison.push({ 
              token: dexTokenName, 
              dexTotalUsdt: token.totalUsdt, 
              cexTotalUsdt: cexToken.totalUsdt, 
              difference 
            });
          }
        }
      }
    }
    result.comparison = comparison.filter(c => c.token !== 'usdt' && c.token !== 'usdc');

    res.json(result);
  } catch (err) {
    console.error('[api:/balances/exchanges] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/trades', (req, res) => {
  try {
    const limit = Math.max(1, Math.min(parseInt(req.query.limit) || 1000, 10000));
    const pair = req.query.pair ? String(req.query.pair) : null;
    const db = getDbFromReq(req);
    let rows;
    if (pair) {
      rows = db.prepare(
        'SELECT * FROM completed_trades WHERE pair = ? ORDER BY COALESCE(lastUpdateTime, creationTime) DESC LIMIT ?'
      ).all(pair, limit);
    } else {
      rows = db.prepare(
        'SELECT * FROM completed_trades ORDER BY COALESCE(lastUpdateTime, creationTime) DESC LIMIT ?'
      ).all(limit);
    }
    res.json(rows);
  } catch (err) {
    console.error('[api:/trades] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Distinct pairs for UI filters
app.get('/trades/pairs', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const rows = db.prepare(
      `SELECT pair, COUNT(*) AS cnt
       FROM completed_trades
       WHERE pair IS NOT NULL AND TRIM(pair) <> ''
       GROUP BY pair
       ORDER BY cnt DESC, pair ASC
       LIMIT 2000`
    ).all();
    res.json(rows.map(r => r.pair));
  } catch (err) {
    console.error('[api:/trades/pairs] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Aggregated analytics per pair (profit/loss, win rate, feature means)
app.get('/trades/analytics/pairs', (req, res) => {
  try {
    const limit = Math.max(1, Math.min(parseInt(req.query.limit) || 5000, 20000));
    const db = getDbFromReq(req);
    const rows = db.prepare(
      "SELECT pair, executedGrossProfit, executedTime, executedSrcPrice, executedQtySrc, executedQtyDst, executedDstPrice, props, raw_data FROM completed_trades ORDER BY COALESCE(lastUpdateTime, creationTime) DESC LIMIT ?"
    ).all(limit);

    const m = new Map();
    for (const r of rows) {
      const pair = r.pair;
      if (!m.has(pair)) {
        m.set(pair, {
          pair,
          trades: 0,
          wins: 0,
          losses: 0,
          totalGrossProfit: 0,
          totalNetProfit: 0,
          sumProfitPos: 0,
          sumProfitNeg: 0,
          sumExecTime: 0,
          sumQty: 0,
          // props feature sums overall and split by win/loss
          sums: { Diff: 0, DexSlip: 0, CexSlip: 0 },
          sumsPos: { Diff: 0, DexSlip: 0, CexSlip: 0 },
          sumsNeg: { Diff: 0, DexSlip: 0, CexSlip: 0 },
          cnts: { Diff: 0, DexSlip: 0, CexSlip: 0 },
          cntsPos: { Diff: 0, DexSlip: 0, CexSlip: 0 },
          cntsNeg: { Diff: 0, DexSlip: 0, CexSlip: 0 },
        });
      }
      const rec = m.get(pair);
      const gp = Number(r.executedGrossProfit) || 0;
      const netProfit = (r.executedQtyDst * r.executedDstPrice) - (r.executedSrcPrice * r.executedQtySrc) - (0.0002 * r.executedQtyDst * r.executedDstPrice);
      const execTime = Number(r.executedTime) || 0;
      const qty = (Number(r.executedSrcPrice) || 0) * (Number(r.executedQtySrc) || 0);
      const props = normalizePropsRaw(r.props);
      const diff = Number(props.Diff);
      const dexSlip = Number(props.DexSlip);
      const cexSlip = Number(props.CexSlip);

      rec.trades += 1;
      rec.totalGrossProfit += gp;
      rec.totalNetProfit += netProfit;
      rec.sumExecTime += execTime;
      rec.sumQty += qty;
      if (gp > 0) { rec.wins += 1; rec.sumProfitPos += gp; }
      else if (gp < 0) { rec.losses += 1; rec.sumProfitNeg += gp; }

      if (Number.isFinite(diff)) { rec.sums.Diff += diff; rec.cnts.Diff++; if (gp>0) {rec.sumsPos.Diff+=diff; rec.cntsPos.Diff++;} else if (gp<0){rec.sumsNeg.Diff+=diff; rec.cntsNeg.Diff++;} }
      if (Number.isFinite(dexSlip)) { rec.sums.DexSlip += dexSlip; rec.cnts.DexSlip++; if (gp>0) {rec.sumsPos.DexSlip+=dexSlip; rec.cntsPos.DexSlip++;} else if (gp<0){rec.sumsNeg.DexSlip+=dexSlip; rec.cntsNeg.DexSlip++;} }
      if (Number.isFinite(cexSlip)) { rec.sums.CexSlip += cexSlip; rec.cnts.CexSlip++; if (gp>0) {rec.sumsPos.CexSlip+=cexSlip; rec.cntsPos.CexSlip++;} else if (gp<0){rec.sumsNeg.CexSlip+=cexSlip; rec.cntsNeg.CexSlip++;} }
    }

    const result = Array.from(m.values()).map(r => {
      const avg = (sum, cnt) => (cnt > 0 ? sum / cnt : null);
      const trades = r.trades || 1;
      return {
        pair: r.pair,
        trades: r.trades,
        wins: r.wins,
        losses: r.losses,
        winRate: r.trades ? r.wins / r.trades : null,
        totalGrossProfit: r.totalGrossProfit,
        totalNetProfit: r.totalNetProfit,
        avgGrossProfit: r.totalGrossProfit / trades,
        avgNetProfit: r.totalNetProfit / trades,
        sumProfitPos: r.sumProfitPos,
        sumProfitNeg: r.sumProfitNeg,
        avgExecTime: r.sumExecTime / trades,
        avgQty: r.sumQty / trades,
        features: {
          Diff: { avg: avg(r.sums.Diff, r.cnts.Diff), avgWin: avg(r.sumsPos.Diff, r.cntsPos.Diff), avgLoss: avg(r.sumsNeg.Diff, r.cntsNeg.Diff) },
          DexSlip: { avg: avg(r.sums.DexSlip, r.cnts.DexSlip), avgWin: avg(r.sumsPos.DexSlip, r.cntsPos.DexSlip), avgLoss: avg(r.sumsNeg.DexSlip, r.cntsNeg.DexSlip) },
          CexSlip: { avg: avg(r.sums.CexSlip, r.cnts.CexSlip), avgWin: avg(r.sumsPos.CexSlip, r.cntsPos.CexSlip), avgLoss: avg(r.sumsNeg.CexSlip, r.cntsNeg.CexSlip) }
        }
      };
    });

    // Sort helpers
    const topWinners = [...result].sort((a,b)=> (b.totalNetProfit)-(a.totalNetProfit)).slice(0,50);
    const topLosers = [...result].sort((a,b)=> (a.totalNetProfit)-(b.totalNetProfit)).slice(0,50);

    res.json({ generatedAt: new Date().toISOString(), limit, totalPairs: result.length, topWinners, topLosers, pairs: result });
  } catch (err) {
    console.error('[api:/trades/analytics/pairs] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/trades/analytics/tokens', (req, res) => {
  try {
    const limit = Math.max(1, Math.min(parseInt(req.query.limit) || 5000, 20000));
    const db = getDbFromReq(req);
    const rows = db.prepare(
      "SELECT pair, executedGrossProfit, executedTime, executedSrcPrice, executedQtySrc, executedQtyDst, executedDstPrice, props, raw_data FROM completed_trades ORDER BY COALESCE(lastUpdateTime, creationTime) DESC LIMIT ?"
    ).all(limit);

    const metrics = aggregateTokenMetrics(rows);

    const result = Array.from(metrics.values()).map(r => ({
      token: r.token,
      trades: r.trades,
      wins: r.wins,
      losses: r.losses,
      totalGrossProfit: r.totalGrossProfit,
      totalNetProfit: r.totalNetProfit,
      winRate: r.trades ? r.wins / r.trades : null,
      avgNetProfit: r.trades ? r.totalNetProfit / r.trades : null,
      avgCexSlip: r.countCexSlip > 0 ? r.sumCexSlip / r.countCexSlip : null,
      avgDexSlip: r.countDexSlip > 0 ? r.sumDexSlip / r.countDexSlip : null,
      avgDiff: r.countDiff > 0 ? r.sumDiff / r.countDiff : null,
    }));

    const topWinners = [...result].sort((a, b) => (b.totalNetProfit) - (a.totalNetProfit)).slice(0, 50);
    const topLosers = [...result].sort((a, b) => (a.totalNetProfit) - (b.totalNetProfit)).slice(0, 50);

    res.json({ generatedAt: new Date().toISOString(), limit, totalTokens: result.length, topWinners, topLosers, tokens: result });
  } catch (err) {
    console.error('[api:/trades/analytics/tokens] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.delete('/trades/:id', (req, res) => {
  try {
    const db = getDbFromReq(req);
    const id = req.params.id;
    const stmt = db.prepare('DELETE FROM completed_trades WHERE id = ?');
    const info = stmt.run(id);

    if (info.changes > 0) {
      res.status(200).json({ success: true, message: 'Trade deleted successfully' });
    } else {
      res.status(404).json({ success: false, message: 'Trade not found' });
    }
  } catch (err) {
    console.error('[api:/trades/:id] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/analysis/server-tokens', async (req, res) => {
  try {
    const db = getDbFromReq(req);

    // 1. Get latest buy/sell for each token
    const tokenData = db.prepare(`
      SELECT name, buy, sell
      FROM (
        SELECT *, ROW_NUMBER() OVER(PARTITION BY name ORDER BY timestamp DESC) as rn
        FROM server_tokens
      )
      WHERE rn = 1
    `).all();
    const tokenMap = new Map(tokenData.map(t => [t.name.toLowerCase(), t]));

    // 2. Aggregate profit data from completed trades
    const tradeRows = db.prepare(
      "SELECT executedGrossProfit, executedQtyDst, executedDstPrice, executedSrcPrice, executedQtySrc, props, raw_data FROM completed_trades"
    ).all();

    const metrics = aggregateTokenMetrics(tradeRows);

    const result = Array.from(metrics.values()).map(r => {
      const symbol = tokenSymbolFromCurId(r.token);
      const tokenInfo = symbol ? tokenMap.get((symbol || '').toLowerCase()) : null;
      return {
        token: r.token,
        buy: tokenInfo?.buy ?? null,
        sell: tokenInfo?.sell ?? null,
        totalNetProfit: r.totalNetProfit,
        trades: r.trades,
      };
    });

    res.json(result);

  } catch (err) {
    console.error('[api:/analysis/server-tokens] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/analysis/token-time-patterns', (req, res) => {
  try {
    const token = req.query.token ? String(req.query.token) : null;
    if (!token) {
      return res.status(400).json({ error: 'Token parameter is required' });
    }

    const targetDateStr = req.query.targetDate;
    const targetDate = targetDateStr ? new Date(targetDateStr) : new Date();
    targetDate.setUTCHours(0, 0, 0, 0);

    // Calculate date ranges for the request
    const dayStartTs = targetDate.getTime();
    const dayEndTs = dayStartTs + (24 * 60 * 60 * 1000) - 1;

    const dayOfWeek = targetDate.getUTCDay(); // 0=Sun
    const weekStart = new Date(targetDate);
    weekStart.setUTCDate(targetDate.getUTCDate() - dayOfWeek);
    const weekStartTs = weekStart.getTime();
    const weekEndTs = weekStartTs + (7 * 24 * 60 * 60 * 1000) - 1;

    const db = getDbFromReq(req);

    // Fetch all trades for the relevant week
    const tradeRows = db.prepare(
      "SELECT executedGrossProfit, executedQtyDst, executedDstPrice, executedSrcPrice, executedQtySrc, lastUpdateTime, creationTime, props, raw_data FROM completed_trades WHERE COALESCE(lastUpdateTime, creationTime) BETWEEN ? AND ?"
    ).all(weekStartTs, weekEndTs);

    const byHour = Array(24).fill(0).map((_, i) => ({ hour: i, netProfit: 0, sumCexSlip: 0, countCexSlip: 0, sumDexSlip: 0, countDexSlip: 0 }));
    const byDay = Array(7).fill(0).map((_, i) => ({ day: i, netProfit: 0, sumCexSlip: 0, countCexSlip: 0, sumDexSlip: 0, countDexSlip: 0 }));

    for (const r of tradeRows) {
      const tokens = extractTokensFromTrade(r);
      if (tokens.includes(token)) {
        const timestamp = r.lastUpdateTime || r.creationTime;
        if (!timestamp) continue;

        const date = new Date(timestamp);
        const props = normalizePropsRaw(r.props);
        const netProfit = (r.executedQtyDst * r.executedDstPrice) - (r.executedSrcPrice * r.executedQtySrc) - (0.0002 * r.executedQtyDst * r.executedDstPrice);

        // Accumulate for Day of Week chart (all trades in the week)
        const day = date.getUTCDay();
        if (day >= 0 && day < 7) {
            if (Number.isFinite(netProfit)) byDay[day].netProfit += netProfit;
            if (Number.isFinite(props.CexSlip)) { byDay[day].sumCexSlip += props.CexSlip; byDay[day].countCexSlip++; }
            if (Number.isFinite(props.DexSlip)) { byDay[day].sumDexSlip += props.DexSlip; byDay[day].countDexSlip++; }
        }

        // Accumulate for Hour of Day chart (only trades on the targetDate)
        if (timestamp >= dayStartTs && timestamp <= dayEndTs) {
            const hour = date.getUTCHours();
            if (hour >= 0 && hour < 24) {
                if (Number.isFinite(netProfit)) byHour[hour].netProfit += netProfit;
                if (Number.isFinite(props.CexSlip)) { byHour[hour].sumCexSlip += props.CexSlip; byHour[hour].countCexSlip++; }
                if (Number.isFinite(props.DexSlip)) { byHour[hour].sumDexSlip += props.DexSlip; byHour[hour].countDexSlip++; }
            }
        }
      }
    }

    const finalByHour = byHour.map(h => ({
        hour: h.hour,
        netProfit: h.netProfit,
        avgCexSlip: h.countCexSlip > 0 ? h.sumCexSlip / h.countCexSlip : null,
        avgDexSlip: h.countDexSlip > 0 ? h.sumDexSlip / h.countDexSlip : null,
    }));

    const finalByDay = byDay.map(d => ({
        day: d.day,
        netProfit: d.netProfit,
        avgCexSlip: d.countCexSlip > 0 ? d.sumCexSlip / d.countCexSlip : null,
        avgDexSlip: d.countDexSlip > 0 ? d.sumDexSlip / d.countDexSlip : null,
    }));

    res.json({ byHour: finalByHour, byDay: finalByDay, dateRange: { day: targetDate.toISOString().split('T')[0], weekStart: weekStart.toISOString().split('T')[0], weekEnd: new Date(weekEndTs).toISOString().split('T')[0] } });

  } catch (err) {
    console.error('[api:/analysis/token-time-patterns] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/analysis/token-time-series', (req, res) => {
  try {
    const token = req.query.token ? String(req.query.token) : null;
    if (!token) {
      return res.status(400).json({ error: 'Token parameter is required' });
    }

    const db = getDbFromReq(req);

    // 1. Get time-bucketed profits
    const tradeRows = db.prepare(
      "SELECT executedGrossProfit, executedQtyDst, executedDstPrice, executedSrcPrice, executedQtySrc, lastUpdateTime, creationTime, props, raw_data FROM completed_trades"
    ).all();

    const profitByHour = new Map();
    for (const r of tradeRows) {
      const tokens = extractTokensFromTrade(r);
      if (tokens.includes(token)) {
        const timestamp = r.lastUpdateTime || r.creationTime;
        if (!timestamp) continue;

        const hour = new Date(timestamp);
        hour.setMinutes(0, 0, 0);

        const netProfit = (r.executedQtyDst * r.executedDstPrice) - (r.executedSrcPrice * r.executedQtySrc) - (0.0002 * r.executedQtyDst * r.executedDstPrice);
        if (!Number.isFinite(netProfit)) continue;

        const hourKey = hour.toISOString();
        profitByHour.set(hourKey, (profitByHour.get(hourKey) || 0) + netProfit);
      }
    }

    // 2. Get time-bucketed buy/sell
    const tokenSymbol = tokenSymbolFromCurId(token);
    const tokenRows = tokenSymbol
      ? db.prepare("SELECT timestamp, buy, sell FROM server_tokens WHERE lower(name) = ?").all(tokenSymbol.toLowerCase())
      : [];

    const buySellByHour = new Map();
    for (const r of tokenRows) {
        const hour = new Date(r.timestamp);
        hour.setMinutes(0, 0, 0);
        const hourKey = hour.toISOString();

        if (!buySellByHour.has(hourKey)) {
            buySellByHour.set(hourKey, { buys: [], sells: [] });
        }
        buySellByHour.get(hourKey).buys.push(r.buy);
        buySellByHour.get(hourKey).sells.push(r.sell);
    }

    // 3. Combine into a single time series
    const allHours = new Set([...profitByHour.keys(), ...buySellByHour.keys()]);
    const sortedHours = Array.from(allHours).sort();

    const result = sortedHours.map(hour => {
        const buySellData = buySellByHour.get(hour);
        let avgBuy = null;
        let avgSell = null;
        if (buySellData) {
            avgBuy = buySellData.buys.reduce((a, b) => a + b, 0) / buySellData.buys.length;
            avgSell = buySellData.sells.reduce((a, b) => a + b, 0) / buySellData.sells.length;
        }

        return {
            timestamp: hour,
            netProfit: profitByHour.get(hour) || 0,
            avgBuy,
            avgSell,
        };
    });

    res.json(result);

  } catch (err) {
    console.error('[api:/analysis/token-time-series] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Server configuration APIs
app.get('/servers', (req, res) => { res.json(loadServers()); });
app.get('/servers/active', (req, res) => { res.json(getActiveServer()); });
app.post('/servers', (req, res) => {
  try {
    const { label, baseUrl, balancesPath = '/balance', completedPath = '/completed', contractAddress, explorerSite, explorerApiBase, explorerApiKey, chainId, id } = req.body || {};
    if (!label || !baseUrl) return res.status(400).json({ error: 'label and baseUrl required' });

    let parsedChainId;
    if (chainId !== undefined && chainId !== null && String(chainId).trim() !== '') {
      const n = Number(chainId);
      if (!Number.isFinite(n)) return res.status(400).json({ error: 'chainId must be a number' });
      parsedChainId = n;
    }

    const cfg = loadServers();
    const newId = id || label.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '-' + Date.now().toString(36);
    const entry = { id: newId, label, baseUrl, balancesPath, completedPath, contractAddress, explorerSite, explorerApiBase, explorerApiKey };
    entry.notifications = normalizeNotificationSettings(req.body?.notifications);
    if (parsedChainId !== undefined) entry.chainId = parsedChainId;
    cfg.servers.push(entry);
    if (!cfg.activeId) cfg.activeId = newId;
    saveServers(cfg);
    res.json({ ok: true, id: newId });
  } catch (e) { res.status(500).json({ error: e.message }); }
});
app.put('/servers/:id', (req, res) => {
  try {
    const cfg = loadServers();
    const i = cfg.servers.findIndex(s => s.id === req.params.id);
    if (i < 0) return res.status(404).json({ error: 'not found' });
    const s = cfg.servers[i];
    const { label, baseUrl, balancesPath, completedPath, contractAddress, explorerSite, explorerApiBase, explorerApiKey, chainId, notifications } = req.body || {};
    if (label != null) s.label = label;
    if (baseUrl != null) s.baseUrl = baseUrl;
    if (balancesPath != null) s.balancesPath = balancesPath;
    if (completedPath != null) s.completedPath = completedPath;
    if (contractAddress != null) s.contractAddress = contractAddress;
    if (explorerSite != null) s.explorerSite = explorerSite;
    if (explorerApiBase != null) s.explorerApiBase = explorerApiBase;
    if (explorerApiKey != null) s.explorerApiKey = explorerApiKey;
    if (chainId !== undefined) {
      if (chainId === null || String(chainId).trim() === '') {
        delete s.chainId;
      } else {
        const n = Number(chainId);
        if (!Number.isFinite(n)) return res.status(400).json({ error: 'chainId must be a number' });
        s.chainId = n;
      }
    }
    if (notifications != null) s.notifications = normalizeNotificationSettings(notifications);
    cfg.servers[i] = s; saveServers(cfg);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});
app.delete('/servers/:id', (req, res) => {
  try {
    const cfg = loadServers();
    cfg.servers = cfg.servers.filter(s => s.id !== req.params.id);
    if (cfg.activeId === req.params.id) cfg.activeId = cfg.servers[0]?.id || null;
    saveServers(cfg);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});
app.post('/servers/:id/select', (req, res) => {
  try {
    const cfg = loadServers();
    if (!cfg.servers.find(s => s.id === req.params.id)) return res.status(404).json({ error: 'not found' });
    cfg.activeId = req.params.id; saveServers(cfg);
    res.json({ ok: true });
  } catch (e) { res.status(500).json({ error: e.message }); }
});

// Bot status summary endpoint
app.get('/status/summary', async (req, res) => {
  try {
    const server = getActiveServer();
    if (!server || !server.baseUrl) {
      return res.status(404).json({ error: 'Active server not configured' });
    }

    const resp = await axios.get(server.baseUrl, { timeout: 10000 });
    const text = resp.data;

    if (typeof text !== 'string') {
      return res.status(500).json({ error: 'Invalid status response from server' });
    }

    const lines = text.split(/\r?\n/);
    const sdiffLine = lines.find(l => l.startsWith('SDIFF_Uniswap_ckhvar2'));
    const blacklistLine = lines.find(l => l.startsWith('SDIFF Uniswap BlackList:'));

    let sdiffData = null;
    if (sdiffLine) {
      const parts = sdiffLine.split(/\s+/);
      const propsIndex = sdiffLine.indexOf('Mindiff:');
      const propsStr = propsIndex > -1 ? sdiffLine.substring(propsIndex) : '';

      sdiffData = {
        id: parts[0],
        addr: parts[1],
        errCnt: parts[2],
        state: parts[3],
        up: parts[4],
        lc: parts[5],
        clean: parts[6],
        ordSz: parts[7],
        mAvg: parts[8],
        tLmt: parts[9],
        vDur: parts[10],
        mxE: parts[11],
        pro50: parts[15],
        pro100: parts[16],
        total: parts[22],
        props: propsStr,
      };
    }

    let blacklistData = null;
    if (blacklistLine) {
      const str = blacklistLine.replace('SDIFF Uniswap BlackList:', '').trim();
      blacklistData = str.split(',')
        .map(item => item.trim())
        .filter(Boolean)
        .map(item => {
          const [key, value] = item.split(':');
          if (key && value !== undefined) {
            const valNum = parseFloat(value);
            return { contract: key, gas: valNum, isLow: valNum < 2 };
          }
          return null;
        }).filter(Boolean);
    }

    res.json({ sdiff: sdiffData, blacklist: blacklistData });

  } catch (err) {
    console.error('[api:/status/summary] error:', err.message);
    res.status(500).json({ error: 'Failed to fetch server status' });
  }
});

// Health endpoint
app.get('/health', (req, res) => {
  res.json({ ok: true, time: new Date().toISOString() });
});

app.post('/logout', (req, res) => {
  res.clearCookie('loggedIn');
  res.clearCookie('username');
  res.clearCookie('userRole');
  res.json({ success: true });
});

// WARNING: Storing passwords in plain text is highly insecure and should NEVER be used in a production environment.
// This is implemented solely for demonstration purposes as per user request.
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  try {
    const users = JSON.parse(fs.readFileSync(SERVERS_FILE.replace('servers.json', 'users.json'), 'utf8'));
    if (users[username] === password) {
      // Insecure: For demonstration only. In production, use secure, signed, HTTP-only cookies.
      const role = username === 'admin' ? 'admin' : 'user';
      const cookieOptions = { httpOnly: false, secure: false, maxAge: 3600000 };
      res.cookie('loggedIn', 'true', cookieOptions); // 1 hour
      res.cookie('username', username, cookieOptions);
      res.cookie('userRole', role, cookieOptions);
      res.json({ success: true, role });
    } else {
      res.status(401).json({ success: false, message: 'Invalid credentials' });
    }
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ success: false, message: 'Internal server error' });
  }
});

app.get('/status/server', async (req, res) => {
  try {
    const server = getActiveServer();
    if (!server || !server.baseUrl) {
      return res.status(404).json({ error: 'Active server not configured' });
    }

    const serverIp = server.baseUrl.split(':')[1].substring(2);
    const resp = await axios.get(`http://${serverIp}:3001/`, { timeout: 10000 });
    const text = resp.data;

    if (typeof text !== 'string') {
      return res.status(500).json({ error: 'Invalid status response from server' });
    }

    const lines = text.split(/\r?\n/);
    const sdiffLine = lines.find(l => l.startsWith('SDIFF_Uniswap_ckhvar2'));
    const blacklistLine = lines.find(l => l.startsWith('SDIFF Uniswap BlackList:'));

    let sdiffData = null;
    if (sdiffLine) {
      const parts = sdiffLine.split(/\s+/);
      const propsIndex = sdiffLine.indexOf('Mindiff:');
      const propsStr = propsIndex > -1 ? sdiffLine.substring(propsIndex) : '';

      const tokens = propsStr.match(/\w+\([\d.]+,[\d.]+\)/g)?.map(t => {
        const [name, values] = t.split('(');
        const [buy, sell] = values.slice(0, -1).split(',');
        return { name, buy, sell };
      });

      const m1Index = parts.findIndex(p => p === 'M1');
      const up = m1Index !== -1 && parts.length > m1Index + 1 ? parts[m1Index + 1] : null;

      sdiffData = {
        up: up,
        mindiff: propsStr.match(/Mindiff:([\d.]+)/)?.[1],
        maxOrderSize: propsStr.match(/MaxOrderSize: (\d+)/)?.[1],
        tokens: tokens,
      };
    }

    let blacklistData = null;
    if (blacklistLine) {
      const str = blacklistLine.replace('SDIFF Uniswap BlackList:', '').trim();
      blacklistData = str.split(',')
        .map(item => item.trim())
        .filter(Boolean)
        .map(item => {
          const [key, value] = item.split(':');
          if (key && value !== undefined) {
            const valNum = parseFloat(value);
            return { contract: key, gas: valNum, isLow: valNum < 2 };
          }
          return null;
        }).filter(Boolean);
    }

    const db = getDbFromReq(req);
    const trades = db.prepare('SELECT * FROM completed_trades ORDER BY lastUpdateTime DESC LIMIT 5000').all();

    const netProfit = (t) => (t.executedQtyDst * t.executedDstPrice) - (t.executedSrcPrice * t.executedQtySrc) - (0.0002 * t.executedQtyDst * t.executedDstPrice);

    // Time-based calculations
    const now = Date.now();
    const oneHourAgo = now - (1 * 60 * 60 * 1000);
    const fourHoursAgo = now - (4 * 60 * 60 * 1000);
    const eightHoursAgo = now - (8 * 60 * 60 * 1000);
    const twelveHoursAgo = now - (12 * 60 * 60 * 1000);
    const twentyFourHoursAgo = now - (24 * 60 * 60 * 1000);

    // Filter trades by time periods from the larger dataset
    const tradesLast1h = trades.filter(t => t.lastUpdateTime >= oneHourAgo);
    const tradesLast4h = trades.filter(t => t.lastUpdateTime >= fourHoursAgo);
    const tradesLast8h = trades.filter(t => t.lastUpdateTime >= eightHoursAgo);
    const tradesLast12h = trades.filter(t => t.lastUpdateTime >= twelveHoursAgo);
    
    // For 24h, query database directly to ensure we get all trades in that period
    const tradesLast24h = db.prepare('SELECT * FROM completed_trades WHERE lastUpdateTime >= ? ORDER BY lastUpdateTime DESC').all(twentyFourHoursAgo);

    // Calculate profits for each time period
    const profitLast1h = tradesLast1h.reduce((acc, t) => acc + netProfit(t), 0);
    const profitLast4h = tradesLast4h.reduce((acc, t) => acc + netProfit(t), 0);
    const profitLast8h = tradesLast8h.reduce((acc, t) => acc + netProfit(t), 0);
    const profitLast12h = tradesLast12h.reduce((acc, t) => acc + netProfit(t), 0);
    const profitLast24h = tradesLast24h.reduce((acc, t) => acc + netProfit(t), 0);

    res.json({ 
      sdiff: sdiffData, 
      blacklist: blacklistData, 
      profit: {
        last1h: profitLast1h,
        last4h: profitLast4h,
        last8h: profitLast8h,
        last12h: profitLast12h,
        last24h: profitLast24h
      },
      trades: {
        last1h: tradesLast1h.length,
        last4h: tradesLast4h.length,
        last8h: tradesLast8h.length,
        last12h: tradesLast12h.length,
        last24h: tradesLast24h.length
      }
    });

  } catch (err) {
    console.error('[api:/status/server] error:', err.message);
    res.status(500).json({ error: 'Failed to fetch server status' });
  }
});

// --- Throttled Etherscan Client ---
function maskEtherscanUrl(url) {
  try {
    const u = new URL(url);
    if (u.searchParams.has('apikey')) {
      u.searchParams.set('apikey', '***');
    }
    return u.toString();
  } catch {
    return url;
  }

const etherscanQueue = [];
let isEtherscanProcessing = false;

async function processEtherscanQueue() {
  if (isEtherscanProcessing || etherscanQueue.length === 0) return;
  isEtherscanProcessing = true;

  const { url, resolve, reject } = etherscanQueue.shift();
  const masked = maskEtherscanUrl(url);
  try {
    console.log('[etherscan] ->', masked);
    const resp = await axios.get(url, { timeout: 15000 });
    console.log('[etherscan] <-', masked, 'status', resp.status, 'keys', Object.keys(resp.data || {}));
    resolve(resp.data);
  } catch (error) {
    console.error('[etherscan] x', masked, error.message);
    reject(error);
  }

  setTimeout(() => {
    isEtherscanProcessing = false;
    processEtherscanQueue();
  }, 1000); // 1 request per second

function fetchThrottledEtherscan(url) {
  return new Promise((resolve, reject) => {
    etherscanQueue.push({ url, resolve, reject });
    processEtherscanQueue();
  });

// Contract analysis for configured server
app.get('/contracts/analysis', async (req, res) => {
  try {
    const serverId = req.query.serverId || loadServers().activeId;
    const db = ensureDb(serverId);

    // Fetch latest transactions and store them
    const server = (loadServers().servers.find(s => s.id === serverId)) || getActiveServer();
    await fetchContractTxsAndStoreFor(server);

    const rows = db.prepare('SELECT * FROM contract_transactions WHERE serverId = ? ORDER BY timestamp DESC').all(serverId);

    const since24h = Date.now() - (24 * 60 * 60 * 1000);
    const recent = rows.filter(t => t.timestamp >= since24h);

    const buckets = [1, 4, 8, 12, 24];
    const now = Date.now();
    const periods = {};
    for (const h of buckets) periods[`${h}h`] = { success: 0, fail: 0 };
    for (const t of recent) {
      const ageH = (now - t.timestamp) / (60 * 60 * 1000);
      for (const h of buckets) {
        if (ageH <= h) {
          if (!t.isError) periods[`${h}h`].success++; else periods[`${h}h`].fail++;
        }
      }
    }

    const failed = recent.filter(t => t.isError).slice(0, 100);

    const failedWithReasons = failed.map(t => {
      const raw = safeJsonParse(t.raw_data);
      const gasPrice = raw ? safeNumber(raw.gasPrice) : 0;
      const gasUsed = raw ? safeNumber(raw.gasUsed) : 0;
      const l1Fee = raw ? safeNumber(raw.L1FeesPaid) : 0;
      const gasFee = (gasPrice * gasUsed) + l1Fee;

      const gasFeeInEth = gasFee / 1e18;
      let price = 0;
      if (t.ethPrice) {
        price = t.ethPrice;
      } else if (t.polPrice) {
        price = t.polPrice;
      } else if (t.bnbPrice) {
        price = t.bnbPrice;
      } else {
        if (server.explorerSite === 'https://polygonscan.com') {
          price = polPrice;
        } else if (server.explorerSite === 'https://bscscan.com') {
          price = bnbPrice;
        } else {
          price = ethPrice;
        }
      }
      const gasFeeInUsdt = price ? gasFeeInEth * price : 0;

      const explorerBase = (server.explorerSite || '').replace(/\/?$/, '');
      const traceUrl = explorerBase ? `${explorerBase}/vmtrace?txhash=${t.hash}&type=gethtrace2` : null;
      return {
        hash: t.hash,
        time: new Date(t.timestamp).toISOString(),
        reason: t.reason,
        gasFee: gasFeeInUsdt,
        link: explorerBase ? `${explorerBase}/tx/${t.hash}` : null,
        traceUrl
      };
    });

    res.json({ serverId, address: server.contractAddress, periods, failed: failedWithReasons, totalAnalyzed: recent.length, chainId: Number.isFinite(server.chainId) ? server.chainId : undefined });
  } catch (err) {
    console.error('[api:/contracts/analysis] error:', err.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});


const { spawn } = require('child_process');

app.post('/ml/train', (req, res) => {
    const pythonProcess = spawn('python', ['train.py']);

    let dataToSend = '';
    pythonProcess.stdout.on('data', (data) => {
        dataToSend += data.toString();
    });

    let errorToSend = '';
    pythonProcess.stderr.on('data', (data) => {
        errorToSend += data.toString();
    });

    pythonProcess.on('close', (code) => {
        if (code !== 0) {
            console.error(`train.py stderr: ${errorToSend}`);
            return res.status(500).json({ message: 'Failed to train model.', details: errorToSend });
        }
        res.json({ message: 'Model trained successfully.', details: dataToSend });
    });
});

app.post('/ml/predict', (req, res) => {
    const { buyDiffBps, sellDiffBps, Diff, DexSlip, CexSlip } = req.body;

    if ([buyDiffBps, sellDiffBps, Diff, DexSlip, CexSlip].some(v => v === undefined)) {
        return res.status(400).json({ error: 'Missing one or more required features.' });
    }

    const pythonProcess = spawn('python', [
        'predict.py',
        buyDiffBps,
        sellDiffBps,
        Diff,
        DexSlip,
        CexSlip
    ]);

    let dataToSend = '';
    pythonProcess.stdout.on('data', (data) => {
        dataToSend += data.toString();
    });

    let errorToSend = '';
    pythonProcess.stderr.on('data', (data) => {
        errorToSend += data.toString();
    });

    pythonProcess.on('close', (code) => {
        if (code !== 0) {
            console.error(`predict.py stderr: ${errorToSend}`);
            return res.status(500).json({ error: 'Failed to get prediction.', details: errorToSend });
        }
        try {
            const result = JSON.parse(dataToSend);
            res.json(result);
        } catch (e) {
            res.status(500).json({ error: 'Failed to parse prediction output.', details: dataToSend });
        }
    });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server listening on http://0.0.0.0:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nShutting down...');
  try { for (const d of dbCache.values()) d.close(); } catch (_) {}
  process.exit(0);
});



